<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Pixi viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body {
      margin:0;
      height:100%;
      overflow:hidden;
      background: transparent;
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;
    }

     #palette-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10;

      padding: 10px 12px 18px;
      width: 170px;
      height: 190px;

      background: rgba(20, 20, 20, 0.92);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      backdrop-filter: blur(14px);

      transition: all 0.25s ease;
    }

    /* Свернутое состояние — аккуратный чип с центральным цветом */
    #palette-panel.collapsed {
      height: auto;
      width: auto;
      padding: 6px 10px 10px;
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
    }

    #palette-panel.collapsed .palette-hexagon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: auto;
      height: auto;
    }

    #palette-panel.collapsed .palette-center {
      position: static;
      transform: none;
      width: 26px;
      height: 26px;
      margin: 0;
    }

    #palette-panel.collapsed .palette-center input {
      border-radius: 999px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.5);
    }

    #palette-panel.collapsed .palette-sector,
    #palette-panel.collapsed .palette-placeholder {
      opacity: 0;
      pointer-events: none;
      width: 0;
      height: 0;
      margin: 0;
    }

    .palette-hexagon {
      position: relative;
      width: 100%;
      height: 100%;
      transition: all 0.3s ease;

      display: grid;
      grid-template-columns: repeat(3, 40px);
      grid-template-rows: repeat(3, 40px);
      gap: 6px;
      align-items: center;
      justify-items: center;
    }

    .palette-center {
      position: static;
      grid-row: 2;
      grid-column: 2;
      width: 40px;
      height: 40px;
      z-index: 3;
      transition: all 0.2s ease;
    }

    .palette-center input {
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }

    .palette-center input:hover {
      transform: scale(1.06);
      box-shadow: 0 6px 16px rgba(0,0,0,0.55);
    }

    .palette-sector {
      position: static;
      width: 36px;
      height: 36px;
      z-index: 2;
    }

    .palette-sector input {
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 3px 8px rgba(0,0,0,0.35);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }

    .palette-sector input:hover {
      transform: scale(1.1);
      box-shadow: 0 5px 14px rgba(0,0,0,0.5);
    }

    /* 3×3 сетка:
       1 2 3
       8 0 4
       7 6 5
       2 и 6 — скрытые плейсхолдеры
    */

    .palette-sector[data-sector="1"] { grid-row: 1; grid-column: 1; } /* ↖ */
    .palette-sector[data-sector="2"] { grid-row: 1; grid-column: 3; } /* ↗ */
    .palette-sector[data-sector="3"] { grid-row: 2; grid-column: 3; } /* → */
    .palette-sector[data-sector="4"] { grid-row: 3; grid-column: 3; } /* ↘ */
    .palette-sector[data-sector="5"] { grid-row: 3; grid-column: 1; } /* ↙ */
    .palette-sector[data-sector="6"] { grid-row: 2; grid-column: 1; } /* ← */

    .palette-placeholder {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      opacity: 0;          /* «квадрат есть, но невидимый» */
      pointer-events: none;
    }

    .palette-placeholder[data-pos="2"] { grid-row: 1; grid-column: 2; }
    .palette-placeholder[data-pos="6"] { grid-row: 3; grid-column: 2; }

    .palette-toggle {
      position: absolute;
      bottom: -26px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(20, 20, 20, 0.95);
      color: #bbb;
      border: none;
      border-radius: 12px;
      padding: 4px 12px;
      font-size: 10px;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.2s ease;
    }

    .palette-toggle:hover {
      background: rgba(40, 40, 40, 0.98);
      color: #fff;
    }

    .palette-toggle:hover {
      background: rgba(40, 40, 40, 0.95);
      color: #fff;
    }
  </style>
</head>
<body>
  <div id="palette-panel" class="collapsed">
    <div class="palette-hexagon">
      <!-- 1 (↖) -->
      <div class="palette-sector" data-sector="1">
        <input class="palette-color" type="color" data-sector="1" title="L2-1 ↖" />
      </div>

      <!-- 2 — пустой, невидимый квадрат -->
      <div class="palette-placeholder" data-pos="2"></div>

      <!-- 3 (↗) -->
      <div class="palette-sector" data-sector="2">
        <input class="palette-color" type="color" data-sector="2" title="L2-2 ↗" />
      </div>

      <!-- 8 (←) -->
      <div class="palette-sector" data-sector="6">
        <input class="palette-color" type="color" data-sector="6" title="L2-6 ←" />
      </div>

      <!-- 0 — центр -->
      <div class="palette-center">
        <input class="palette-color" type="color" data-sector="0" title="Center L1" />
      </div>

      <!-- 4 (→) -->
      <div class="palette-sector" data-sector="3">
        <input class="palette-color" type="color" data-sector="3" title="L2-3 →" />
      </div>

      <!-- 7 (↙) -->
      <div class="palette-sector" data-sector="5">
        <input class="palette-color" type="color" data-sector="5" title="L2-5 ↙" />
      </div>

      <!-- 6 — пустой, невидимый квадрат -->
      <div class="palette-placeholder" data-pos="6"></div>

      <!-- 5 (↘) -->
      <div class="palette-sector" data-sector="4">
        <input class="palette-color" type="color" data-sector="4" title="L2-4 ↘" />
      </div>
    </div>

    <button class="palette-toggle">Палитра</button>
  </div>


  <script src="/PixiJS/pixi.min.js"></script>

  <script>
  (async () => {
    if (!window.PIXI) {
      console.error('PIXI не найден');
      return;
    }

    // ✱ HQ: используем devicePixelRatio (ограничиваем, чтобы не улететь в космос)
    const DPR = Math.min(window.devicePixelRatio || 1, 2.5);

    function getViewportSize() {
      const w = document.documentElement.clientWidth || window.innerWidth || 800;
      const h = document.documentElement.clientHeight || window.innerHeight || 600;
      return { w, h };
    }

    const { w: initW, h: initH } = getViewportSize();

    const app = new PIXI.Application();
    await app.init({
      width: initW,
      height: initH,
      antialias: true,
      resolution: DPR,       // ✱ HQ: повышаем плотность пикселей
      autoDensity: true,     // ✱ HQ: canvas подстраивается под resolution
      backgroundAlpha: 0
      // sampleCount: 4      // если твоя сборка Pixi v8 поддерживает MSAA
    });
    document.body.appendChild(app.canvas);

    // Canvas выше фона, но сам прозрачный
    app.canvas.style.position = 'relative';
    app.canvas.style.zIndex = '1';
    app.canvas.style.background = 'transparent';

    // ✱ HQ: чуть сглаживаем позиционирование
    if (app.renderer) {
      app.renderer.roundPixels = true;
    }

    const container = new PIXI.Container();
    app.stage.addChild(container);

    let lastCells = null;
    let currentMapId = null;

    function resizeApp() {
      const { w, h } = getViewportSize();

      app.renderer.resize(w, h);
      container.x = w / 2;
      container.y = h / 2;

      console.log('Pixi: resizeApp ->', w, 'x', h);
    }

    window.addEventListener('resize', resizeApp);
    setTimeout(resizeApp, 200);

    let isDragging = false;
    let lastMousePosition = null;
    let scale = 1;
    const minScale = 0.5;
    const maxScale = 2;

    app.stage.eventMode = 'static';
    app.stage.hitArea = app.screen;

    app.stage.on('pointerdown', (event) => {
      isDragging = true;
      lastMousePosition = event.global.clone();
    });

    app.stage.on('pointerup', () => {
      isDragging = false;
      lastMousePosition = null;
    });

    app.stage.on('pointerupoutside', () => {
      isDragging = false;
      lastMousePosition = null;
    });

    app.stage.on('pointermove', (event) => {
      if (!isDragging || !lastMousePosition) return;
      const newMousePosition = event.global.clone();
      const deltaX = newMousePosition.x - lastMousePosition.x;
      const deltaY = newMousePosition.y - lastMousePosition.y;
      container.x += deltaX;
      container.y += deltaY;
      lastMousePosition = newMousePosition;
    });

    app.canvas.addEventListener('wheel', (event) => {
      event.preventDefault();
      const zoomSpeed = 0.1;
      const zoomFactor = event.deltaY > 0 ? 1 - zoomSpeed : 1 + zoomSpeed;
      const newScale = Math.min(maxScale, Math.max(minScale, scale * zoomFactor));

      if (newScale !== scale) {
        const mouseX = event.clientX;
        const mouseY = event.clientY;
        const worldPos = {
          x: (mouseX - container.x) / scale,
          y: (mouseY - container.y) / scale
        };
        scale = newScale;
        container.scale.set(scale);
        container.x = mouseX - worldPos.x * scale;
        container.y = mouseY - worldPos.y * scale;
      }
    }, { passive: false });

    const SQRT3 = Math.sqrt(3);
    const size = 42;

    const axialToPixel = (q, r) => ({
      x: size * (SQRT3 * q + SQRT3 / 2 * r),
      y: size * (1.5 * r)
    });

    const createHexPoints = (radius) => {
      const points = [];
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 180) * (60 * i - 30);
        points.push(
          Math.cos(angle) * radius,
          Math.sin(angle) * radius
        );
      }
      return points;
    };

    const HEX_PTS = createHexPoints(size);

    const HEXES = [];
    let selectedHex = null;
    let centerHex = null;

    const clearMap = () => {
      container.removeChildren();
      HEXES.length = 0;
      selectedHex = null;
      centerHex = null;
    };

    function wrapLabel(text, maxCharsSingle = 9, maxLineLenMulti = 10, maxLines = 4) {
      const str = String(text || '').trim();
      if (!str) return '';

      const words = str.split(/\s+/).filter(Boolean);
      const wordCount = words.length;

      const cutWord = (word) => {
        if (word.length <= maxCharsSingle) return word;
        return word.slice(0, maxCharsSingle) + '.';
      };

      if (wordCount === 1) {
        return cutWord(words[0]);
      }

      const lines = [];

      if (wordCount === 2 || wordCount === 3) {
        for (let i = 0; i < wordCount && lines.length < maxLines; i++) {
          lines.push(cutWord(words[i]));
        }
        return lines.join('\n');
      }

      let current = '';

      for (let i = 0; i < wordCount; i++) {
        let w = words[i];

        if (w.length > maxCharsSingle) {
          w = cutWord(w);
        }

        if (!current) {
          current = w;
        } else {
          const candidate = current + ' ' + w;
          if (candidate.length <= maxLineLenMulti) {
            current = candidate;
          } else {
            lines.push(current);
            if (lines.length >= maxLines) break;
            current = w;
          }
        }

        if (i === wordCount - 1 && current && lines.length < maxLines) {
          lines.push(current);
        }

        if (lines.length >= maxLines) break;
      }

      if (current && lines.length < maxLines && lines[lines.length - 1] !== current) {
        lines.push(current);
      }

      if (lines.length > maxLines) {
        lines.length = maxLines;
      }

      for (let i = 0; i < lines.length; i++) {
        const parts = lines[i].split(/\s+/).filter(Boolean);
        if (parts.length === 1 && lines[i].length > maxCharsSingle) {
          lines[i] = cutWord(parts[0]);
        }
      }

      return lines.join('\n');
    }

    const BASE_COLORS = { // <<<<<<< Цвета по умолчанию для карты
      0: 0xffffff,
      1: 0xd99272,
      2: 0xcfbd8c,
      3: 0x64c1b8,
      4: 0x58809c,
      5: 0x7a799f,
      6: 0xde5e61
    };

    function intToHexColor(intVal) {
      let s = intVal.toString(16);
      while (s.length < 6) s = '0' + s;
      return '#' + s;
    }

    function setupPaletteUI() {
      const inputs = document.querySelectorAll('input.palette-color');
      inputs.forEach(input => {
        const sector = Number(input.dataset.sector);
        const base = BASE_COLORS[sector] ?? 0x000000;
        input.value = intToHexColor(base);

        input.addEventListener('input', (e) => {
          const val = e.target.value;
          const intVal = parseInt(val.slice(1), 16);
          if (!Number.isNaN(intVal)) {
            BASE_COLORS[sector] = intVal;
            if (lastCells && Array.isArray(lastCells)) {
              buildFromCells(lastCells);
            }
          }
        });
      });

      const palettePanel = document.getElementById('palette-panel');
      const toggleButton = document.querySelector('.palette-toggle');
      
      toggleButton.addEventListener('click', (e) => {
        e.stopPropagation();
        palettePanel.classList.toggle('collapsed');
      });

      document.addEventListener('click', (e) => {
        if (!palettePanel.contains(e.target)) {
          palettePanel.classList.add('collapsed');
        }
      });

      palettePanel.addEventListener('click', (e) => {
        e.stopPropagation();
      });
    }

    setupPaletteUI();

    function parseLevelVector(cell) {
      const id = (cell && cell.data && cell.data.id) || cell.id || '';
      const m = /^L(\d)(?:-([0-9]+))?(?:-([0-9]+))?/.exec(id);
      let level = null;
      let sector = null;
      let order = null;

      if (m) {
        level = parseInt(m[1], 10);
        if (m[2]) sector = parseInt(m[2], 10);
        if (m[3]) order = parseInt(m[3], 10);
      }

      if (!level) {
        const q = Number(cell.q) || 0;
        const r = Number(cell.r) || 0;
        const s = -q - r;
        const radius = Math.max(Math.abs(q), Math.abs(r), Math.abs(s));
        if (radius === 0) level = 1;
        else if (radius === 1) level = 2;
        else if (radius === 2) level = 3;
        else level = 4;
      }

      return { level, sector, order };
    }

    function getFillStyle(cell) {
      const { level, sector, order } = parseLevelVector(cell);

      if (level === 1) {
        return { color: BASE_COLORS[0], alpha: 1 };
      }

      if (level === 2) {
        const baseColor = (sector && BASE_COLORS[sector]) ? BASE_COLORS[sector] : 0x000000;
        return { color: baseColor, alpha: 1 };
      }

      const baseColor = (sector && BASE_COLORS[sector]) ? BASE_COLORS[sector] : 0x000000;

      if (!sector) {
        return { color: baseColor, alpha: 0 };
      }

      if (level === 3) {
        return { color: baseColor, alpha: 0.5 };
      }

      if (level >= 4) {
        const idx = order || 1;
        const isOdd = idx % 2 === 1;
        const alpha = isOdd ? 0.2 : 0.1;
        return { color: baseColor, alpha };
      }

      return { color: baseColor, alpha: 0 };
    }

    const createHex = (cell) => {
      const q = Number(cell.q) || 0;
      const r = Number(cell.r) || 0;
      const labelText = cell.label || '';
      const { x, y } = axialToPixel(q, r);

      const { color: fillColor, alpha: fillAlpha } = getFillStyle(cell);

      const graphics = new PIXI.Graphics();
      graphics.roundPixels = true; // ✱ HQ
      graphics.poly(HEX_PTS, true)
              .fill(fillColor, fillAlpha)
              .stroke({ color: 0xffffff, width: 2, alpha: 1 }); //<<<<<<<<<<<<<<<<<<<<<<<<<<<<< STROKE

      graphics.x = x;
      graphics.y = y;
      graphics.eventMode = 'static';
      graphics.cursor = 'pointer';
      graphics.hitArea = new PIXI.Polygon(HEX_PTS);

      container.addChild(graphics);

      const wrapped = wrapLabel(labelText);

      // ✱ HQ: текст тоже рендерим с повышенным resolution
      const text = new PIXI.Text({
        text: wrapped,
        style: {
          fill: 0x1e1e1e,
          fontSize: 12,
          fontFamily: 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
          fontWeight: '500',
          align: 'center',
          resolution: DPR
        }
      });
      text.roundPixels = true; // ✱ HQ
      text.anchor.set(0.5);
      text.x = x;
      text.y = y;
      container.addChild(text);

      return {
        graphics,
        text,
        q,
        r,
        selected: false,
        data: cell.data || cell,
        baseFillColor: fillColor,
        baseFillAlpha: fillAlpha
      };
    };

    const applyBaseStyle = (hexObj) => {
      hexObj.graphics
        .clear()
        .poly(HEX_PTS, true)
        .fill(hexObj.baseFillColor, hexObj.baseFillAlpha)
        .stroke({ color: 0xffffff, width: 2, alpha: 1 }); //<<<<<<<<<<<<<<<<<<<<<<<<<<<<< STROKE
    };

    const wireInteractions = (hexObj) => {
      if (hexObj === centerHex) return;

      hexObj.graphics.on('pointerover', () => {
        if (!hexObj.selected) {
          hexObj.graphics.clear()
                .poly(HEX_PTS, true)
                .fill(hexObj.baseFillColor, hexObj.baseFillAlpha)
                .stroke({ color: 0xffffff, width: 4, alpha: 1 }); //<<<<<<<<<<<<<<<<<<<<<<<<<<<<< STROKE
        }
      });

      hexObj.graphics.on('pointerout', () => {
        if (!hexObj.selected) {
          applyBaseStyle(hexObj);
        }
      });

      hexObj.graphics.on('pointertap', () => {
        if (selectedHex && selectedHex !== hexObj) {
          selectedHex.selected = false;
          applyBaseStyle(selectedHex);
        }

        if (hexObj.selected) {
          hexObj.selected = false;
          applyBaseStyle(hexObj);
          selectedHex = null;
        } else {
          hexObj.selected = true;
          selectedHex = hexObj;
          hexObj.graphics.clear()
                .poly(HEX_PTS, true)
                .fill(0x34a2db, 1)
                .stroke({ color: 0xffffff, width: 3, alpha: 1 });

          // Формируем стандартный payload для контейнера
          const payload = {
            map_id: currentMapId,
            node_id: hexObj.data.id,
            label: hexObj.data.label,
            ...hexObj.data
          };

          if (window.parent && window.parent !== window) {
            window.parent.postMessage(
              { type: 'container:set', payload },
              '*'
            );
          }
        }
      });
    };

    function normalizePixiPayload(raw) {
      if (!raw) return { format: 'pixi_hex', cells: [] };

      if (raw.format === 'pixi_hex' && Array.isArray(raw.cells)) {
        return raw;
      }

      let obj = raw;

      if (Array.isArray(obj)) {
        obj = obj[0];
      }

      if (obj && typeof obj === 'object' && '' in obj && typeof obj[''] === 'object') {
        obj = obj[''];
      }

      if (obj && typeof obj === 'object' && !Array.isArray(obj) && !obj.cells) {
        const cells = Object.values(obj).map((cell) => {
          if (!cell || typeof cell !== 'object') return null;
          const q = Number(cell.q) || 0;
          const r = Number(cell.r) || 0;
          const label = cell.label || '';
          const id = cell.id;

          return {
            q,
            r,
            label,
            data: {
              id,
              ...(cell.data || {})
            }
          };
        }).filter(Boolean);

        return { format: 'pixi_hex', cells };
      }

      return raw;
    }

    function buildFromCells(cells) {
      clearMap();

      if (!cells || !cells.length) {
        console.warn('Pixi: пустой список cells');
        return;
      }

      lastCells = cells.slice();

      console.log('Pixi: строим карту из', cells.length, 'ячеек');

      cells.forEach((cell, idx) => {
        const hex = createHex(cell);
        HEXES.push(hex);

        if (idx === 0) {
          centerHex = hex;
        } else {
          wireInteractions(hex);
        }
      });

      console.log('Pixi карта отрисована, всего сот:', HEXES.length);
    }

    function drawMap(raw) {
      console.log('Pixi: raw payload', raw);
      
      // Извлекаем map_id если он есть в payload
      if (raw && raw.map_id) {
        currentMapId = raw.map_id;
        // Убираем map_id из данных карты чтобы не мешал
        const { map_id, ...mapData } = raw;
        raw = mapData;
      }
      
      const norm = normalizePixiPayload(raw);
      console.log('Pixi: normalized payload', norm);
      resizeApp();
      buildFromCells(norm.cells || []);
    }

    window.PixiViewer = { setData: drawMap };

    window.addEventListener('message', (ev) => {
      const msg = ev.data || {};
      if (msg.type === 'map:pixi') {
        drawMap(msg.payload);
      }
      if (msg.type === 'pixi:resize') {
        resizeApp();
      }
    });

    console.log('Pixi viewer готов. Ждёт { type:"map:pixi", payload: ... }');
  })();
  </script>
</body>
</html>
