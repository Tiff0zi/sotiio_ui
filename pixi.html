<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Sotiio Pixi Hex Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #1e1e1e;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    }

    /* ───── ПАЛИТРА СЛОЁВ ───── */
    #palette-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10;

      padding: 10px 12px 18px;
      width: 170px;
      height: 190px;

      background: rgba(20, 20, 20, 0.92);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      backdrop-filter: blur(14px);

      transition: all 0.25s ease;
    }

    /* Свернутое состояние — аккуратный чип с центральным цветом */
    #palette-panel.collapsed {
      height: auto;
      width: auto;
      padding: 6px 10px 10px;
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
    }

    #palette-panel.collapsed .palette-hexagon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: auto;
      height: auto;
    }

    #palette-panel.collapsed .palette-center {
      position: static;
      transform: none;
      width: 26px;
      height: 26px;
      margin: 0;
    }

    #palette-panel.collapsed .palette-center input {
      border-radius: 999px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.5);
    }

    #palette-panel.collapsed .palette-sector,
    #palette-panel.collapsed .palette-placeholder {
      opacity: 0;
      pointer-events: none;
      width: 0;
      height: 0;
      margin: 0;
    }

    .palette-hexagon {
      position: relative;
      width: 100%;
      height: 100%;
      transition: all 0.3s ease;

      display: grid;
      grid-template-columns: repeat(3, 40px);
      grid-template-rows: repeat(3, 40px);
      gap: 6px;
      align-items: center;
      justify-items: center;
    }

    .palette-center {
      position: static;
      grid-row: 2;
      grid-column: 2;
      width: 40px;
      height: 40px;
      z-index: 3;
      transition: all 0.2s ease;
    }

    .palette-center input {
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }

    .palette-center input:hover {
      transform: scale(1.06);
      box-shadow: 0 6px 16px rgba(0,0,0,0.55);
    }

    .palette-sector {
      position: static;
      width: 36px;
      height: 36px;
      z-index: 2;
    }

    .palette-sector input {
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 3px 8px rgba(0,0,0,0.35);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }

    .palette-sector input:hover {
      transform: scale(1.1);
      box-shadow: 0 5px 14px rgba(0,0,0,0.5);
    }

    /* 3×3 сетка:
       1 2 3
       8 0 4
       7 6 5
       2 и 6 — скрытые плейсхолдеры
    */
    .palette-sector[data-sector="1"] { grid-row: 1; grid-column: 1; } /* ↖ */
    .palette-sector[data-sector="2"] { grid-row: 1; grid-column: 3; } /* ↗ */
    .palette-sector[data-sector="3"] { grid-row: 2; grid-column: 3; } /* → */
    .palette-sector[data-sector="4"] { grid-row: 3; grid-column: 3; } /* ↘ */
    .palette-sector[data-sector="5"] { grid-row: 3; grid-column: 1; } /* ↙ */
    .palette-sector[data-sector="6"] { grid-row: 2; grid-column: 1; } /* ← */

    .palette-placeholder {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      opacity: 0;          /* квадрат есть, но невидимый */
      pointer-events: none;
    }

    .palette-placeholder[data-pos="2"] { grid-row: 1; grid-column: 2; }
    .palette-placeholder[data-pos="6"] { grid-row: 3; grid-column: 2; }

    .palette-toggle {
      position: absolute;
      bottom: -26px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(20, 20, 20, 0.95);
      color: #bbb;
      border: none;
      border-radius: 12px;
      padding: 4px 12px;
      font-size: 10px;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.2s ease;
    }

    .palette-toggle:hover {
      background: rgba(40, 40, 40, 0.98);
      color: #fff;
    }
  </style>
</head>
<body>
  <div id="palette-panel" class="collapsed">
    <div class="palette-hexagon">
      <!-- 1 (↖) -->
      <div class="palette-sector" data-sector="1">
        <input class="palette-color" type="color" data-sector="1" title="L2-1 ↖" />
      </div>

      <!-- 2 — пустой, невидимый квадрат -->
      <div class="palette-placeholder" data-pos="2"></div>

      <!-- 3 (↗) -->
      <div class="palette-sector" data-sector="2">
        <input class="palette-color" type="color" data-sector="2" title="L2-2 ↗" />
      </div>

      <!-- 8 (←) -->
      <div class="palette-sector" data-sector="6">
        <input class="palette-color" type="color" data-sector="6" title="L2-6 ←" />
      </div>

      <!-- 0 — центр -->
      <div class="palette-center">
        <input class="palette-color" type="color" data-sector="0" title="Center L1" />
      </div>

      <!-- 4 (→) -->
      <div class="palette-sector" data-sector="3">
        <input class="palette-color" type="color" data-sector="3" title="L2-3 →" />
      </div>

      <!-- 7 (↙) -->
      <div class="palette-sector" data-sector="5">
        <input class="palette-color" type="color" data-sector="5" title="L2-5 ↙" />
      </div>

      <!-- 6 — пустой, невидимый квадрат -->
      <div class="palette-placeholder" data-pos="6"></div>

      <!-- 5 (↘) -->
      <div class="palette-sector" data-sector="4">
        <input class="palette-color" type="color" data-sector="4" title="L2-4 ↘" />
      </div>
    </div>

    <button class="palette-toggle">Палитра</button>
  </div>

  <script src="/PixiJS/pixi.min.js"></script>

  <script>
  (async () => {
    if (!window.PIXI) {
      console.error('PIXI не найден');
      return;
    }

    const DPR = window.devicePixelRatio || 1;

    const app = new PIXI.Application();
    await app.init({
      width: 1,
      height: 1,
      background: '#1e1e1e',
      antialias: true,
      resolution: DPR,
      autoDensity: true
    });
    document.body.appendChild(app.canvas);

    PIXI.settings.ROUND_PIXELS = true;

    const container = new PIXI.Container();
    app.stage.addChild(container);

    function resizeApp() {
      const w = document.documentElement.clientWidth || window.innerWidth || 800;
      const h = document.documentElement.clientHeight || window.innerHeight || 600;

      app.renderer.resize(w, h);
      container.x = w / 2;
      container.y = h / 2;
    }

    window.addEventListener('resize', resizeApp);
    resizeApp();

    // ─── Палитра ─────────────────────────────────
    const palettePanel = document.getElementById('palette-panel');
    const paletteToggle = palettePanel.querySelector('.palette-toggle');
    const paletteInputs = palettePanel.querySelectorAll('.palette-color');
    let paletteCollapsed = true;

    paletteToggle.addEventListener('click', (e) => {
      e.stopPropagation();
      paletteCollapsed = !paletteCollapsed;
      if (paletteCollapsed) {
        palettePanel.classList.add('collapsed');
      } else {
        palettePanel.classList.remove('collapsed');
      }
    });

    palettePanel.addEventListener('click', (e) => {
      e.stopPropagation();
    });

    document.addEventListener('click', () => {
      if (!paletteCollapsed) {
        paletteCollapsed = true;
        palettePanel.classList.add('collapsed');
      }
    });

    // ─── Геометрия ───────────────────────────────
    function axialToPixel(q, r, size) {
      const x = size * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r);
      const y = size * (3 / 2 * r);
      return { x, y };
    }

    function createHexagon(size, fillColor, lineColor) {
      const g = new PIXI.Graphics();
      g.lineStyle(1, lineColor, 1);
      g.beginFill(fillColor, 1);

      const angle = Math.PI / 3;
      for (let i = 0; i < 6; i++) {
        const x = size * Math.cos(angle * i);
        const y = size * Math.sin(angle * i);
        if (i === 0) {
          g.moveTo(x, y);
        } else {
          g.lineTo(x, y);
        }
      }
      g.closePath();
      g.endFill();
      return g;
    }

    // ─── Обёртка текста внутри соты ─────────────
    function wrapLabel(text) {
      if (!text) return '';

      const MAX_CHARS_SINGLE = 9;
      const MAX_LINES = 4;
      const MAX_WORDS_PER_LINE = 1;
      const MAX_LINE_LENGTH_MULTI = 10;

      const words = text.split(/\s+/).filter(Boolean);

      if (words.length === 1 && words[0].length > MAX_CHARS_SINGLE) {
        let w = words[0].slice(0, MAX_CHARS_SINGLE - 1) + '…';
        return w;
      }

      const lines = [];
      let currentLine = '';

      for (let i = 0; i < words.length; i++) {
        const word = words[i];

        if (lines.length >= MAX_LINES) break;

        if (MAX_WORDS_PER_LINE === 1) {
          lines.push(word);
          continue;
        }

        if (!currentLine) {
          currentLine = word;
          continue;
        }

        const testLine = currentLine + ' ' + word;
        if (testLine.length <= MAX_LINE_LENGTH_MULTI) {
          currentLine = testLine;
        } else {
          lines.push(currentLine);
          currentLine = word;
        }
      }

      if (currentLine && lines.length < MAX_LINES) {
        lines.push(currentLine);
      }

      return lines.slice(0, MAX_LINES).join('\n');
    }

    // ─── Отрисовка карты ────────────────────────
    const HEX_SIZE = 40;
    const hexCells = [];

    function drawHexCell(q, r, labelText, fillColor) {
      const { x, y } = axialToPixel(q, r, HEX_SIZE);

      const graphics = createHexagon(HEX_SIZE, fillColor, 0x444444);
      graphics.x = x;
      graphics.y = y;
      graphics.interactive = true;
      graphics.cursor = 'pointer';

      container.addChild(graphics);

      const wrapped = wrapLabel(labelText);
      const text = new PIXI.Text({
        text: wrapped,
        style: {
          fill: 0xffffff,
          fontSize: 11,
          fontFamily: 'system-ui, Arial',
          fontWeight: '500',
          align: 'center'
        }
      });
      text.resolution = DPR;
      text.anchor.set(0.5);
      text.x = x;
      text.y = y;
      container.addChild(text);

      return {
        graphics,
        text,
        q,
        r,
        selected: false,
        data: null
      };
    }

    function drawHexMap(nodes) {
      container.removeChildren();
      hexCells.length = 0;

      nodes.forEach((node) => {
        const { q, r, label, fillColor } = node;
        const cell = drawHexCell(q, r, label, fillColor);
        cell.data = node;
        hexCells.push(cell);
      });

      container.x = app.renderer.width / 2;
      container.y = app.renderer.height / 2;
    }

    function updatePaletteInputs(colorsBySector) {
      paletteInputs.forEach(input => {
        const sector = input.dataset.sector;
        if (sector in colorsBySector) {
          input.value = colorsBySector[sector];
        }
      });
    }

    paletteInputs.forEach(input => {
      input.addEventListener('input', () => {
        const sector = input.dataset.sector;
        const colorValue = input.value;
        const colorNumber = parseInt(colorValue.replace('#', ''), 16);

        hexCells.forEach(cell => {
          if (!cell.data) return;
          if (String(cell.data.sector) === String(sector)) {
            cell.graphics.tint = colorNumber;
          }
        });
      });
    });

    // ─── Панорамирование и зум ──────────────────
    let isPanning = false;
    let lastPan = { x: 0, y: 0 };

    app.stage.eventMode = 'static';
    app.stage.hitArea = app.screen;

    app.stage.on('pointerdown', (event) => {
      isPanning = true;
      lastPan.x = event.global.x;
      lastPan.y = event.global.y;
      app.stage.cursor = 'grabbing';
    });

    app.stage.on('pointermove', (event) => {
      if (!isPanning) return;
      const dx = event.global.x - lastPan.x;
      const dy = event.global.y - lastPan.y;
      lastPan.x = event.global.x;
      lastPan.y = event.global.y;
      container.x += dx;
      container.y += dy;
    });

    app.stage.on('pointerup', () => {
      isPanning = false;
      app.stage.cursor = 'default';
    });

    app.stage.on('pointerupoutside', () => {
      isPanning = false;
      app.stage.cursor = 'default';
    });

    window.addEventListener('wheel', (e) => {
      const scaleFactor = 1.05;
      const oldScale = container.scale.x;
      const mousePos = { x: e.clientX, y: e.clientY };
      const worldPos = {
        x: (mousePos.x - container.x) / oldScale,
        y: (mousePos.y - container.y) / oldScale
      };

      if (e.deltaY < 0) {
        container.scale.x *= scaleFactor;
        container.scale.y *= scaleFactor;
      } else {
        container.scale.x /= scaleFactor;
        container.scale.y /= scaleFactor;
      }

      const newScale = container.scale.x;
      container.x = mousePos.x - worldPos.x * newScale;
      container.y = mousePos.y - worldPos.y * newScale;
    }, { passive: true });

    // ─── Приём карты от index.html ──────────────
    function normalizeColor(c) {
      if (c == null) return 0x555555;
      if (typeof c === 'number') return c;
      let s = String(c).trim();
      if (s.startsWith('#')) s = s.slice(1);
      if (s.startsWith('0x')) s = s.slice(2);
      const n = parseInt(s, 16);
      if (Number.isNaN(n)) return 0x555555;
      return n;
    }

    function drawMap(payload) {
      try {
        const cells = payload && Array.isArray(payload.cells) ? payload.cells : [];

        const nodes = cells.map(c => ({
          q: c.q,
          r: c.r,
          label: c.label,
          fillColor: normalizeColor(c.fillColor),
          node_id: c.node_id,
          sector: c.sector ?? 0
        }));

        const colorsBySector = payload && payload.colorsBySector ? payload.colorsBySector : {
          0: '#ff9800',
          1: '#4caf50',
          2: '#2196f3',
          3: '#9c27b0',
          4: '#f44336',
          5: '#ffeb3b',
          6: '#607d8b'
        };
        updatePaletteInputs(colorsBySector);

        drawHexMap(nodes);
      } catch (err) {
        console.error('Ошибка при отрисовке карты:', err);
      }
    }

    window.addEventListener('message', (ev) => {
      const msg = ev.data || {};
      if (msg.type === 'map:pixi') {
        drawMap(msg.payload);
      }
      if (msg.type === 'pixi:resize') {
        resizeApp();
      }
    });

    console.log('Pixi viewer готов. Ждёт { type: "map:pixi", payload }');
  })();
  </script>
</body>
</html>
