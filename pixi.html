<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Pixi viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body {
      margin:0;
      height:100%;
      overflow:hidden;
      background:#1e1e1e;
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;
    }
  </style>
</head>
<body>
  <!-- тот же путь, что и в hex_test -->
  <script src="./PixiJS/pixi.min.js"></script>

  <script>
  (async () => {
    if (!window.PIXI) {
      console.error('PIXI не найден');
      return;
    }

    const app = new PIXI.Application();
    await app.init({
      width: window.innerWidth,
      height: window.innerHeight,
      background: '#1e1e1e',
      antialias: true,
      resolution: 1
    });
    document.body.appendChild(app.canvas);

    const container = new PIXI.Container();
    app.stage.addChild(container);

    // Начальная позиция - центрируем контейнер
    container.x = app.screen.width / 2;
    container.y = app.screen.height / 2;

    // --- Пан/Зум (1:1 как в hex_test) ---
    let isDragging = false;
    let lastMousePosition = null;
    let scale = 1;
    const minScale = 0.5;
    const maxScale = 2;

    app.stage.eventMode = 'static';
    app.stage.hitArea = app.screen;

    app.stage.on('pointerdown', (event) => {
      isDragging = true;
      lastMousePosition = event.global.clone();
    });

    app.stage.on('pointerup', () => {
      isDragging = false;
      lastMousePosition = null;
    });

    app.stage.on('pointerupoutside', () => {
      isDragging = false;
      lastMousePosition = null;
    });

    app.stage.on('pointermove', (event) => {
      if (!isDragging || !lastMousePosition) return;

      const newMousePosition = event.global.clone();
      const deltaX = newMousePosition.x - lastMousePosition.x;
      const deltaY = newMousePosition.y - lastMousePosition.y;

      container.x += deltaX;
      container.y += deltaY;

      lastMousePosition = newMousePosition;
    });

    app.canvas.addEventListener('wheel', (event) => {
      event.preventDefault();

      const zoomSpeed = 0.1;
      const zoomFactor = event.deltaY > 0 ? 1 - zoomSpeed : 1 + zoomSpeed;
      const newScale = Math.min(maxScale, Math.max(minScale, scale * zoomFactor));

      if (newScale !== scale) {
        const mouseX = event.clientX;
        const mouseY = event.clientY;

        const worldPos = {
          x: (mouseX - container.x) / scale,
          y: (mouseY - container.y) / scale
        };

        scale = newScale;
        container.scale.set(scale);

        container.x = mouseX - worldPos.x * scale;
        container.y = mouseY - worldPos.y * scale;
      }
    }, { passive: false });

    // --- HEX математика (1:1 с hex_test) ---
    const SQRT3 = Math.sqrt(3);
    const size = 42;

    const axialToPixel = (q, r) => ({
      x: size * (SQRT3 * q + SQRT3 / 2 * r),
      y: size * (1.5 * r)
    });

    const createHexPoints = (radius) => {
      const points = [];
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 180) * (60 * i - 30);
        points.push(
          Math.cos(angle) * radius,
          Math.sin(angle) * radius
        );
      }
      return points;
    };

    const HEX_PTS = createHexPoints(size);

    // --- Состояние карты ---
    const HEXES = [];
    let selectedHex = null;
    let centerHex = null; // будем делать «оранжевым центром» первый узел

    const clearMap = () => {
      container.removeChildren();
      HEXES.length = 0;
      selectedHex = null;
      centerHex = null;
    };

    // Создание одной соты (ровно как в hex_test)
    const createHex = (q, r, labelText) => {
      const { x, y } = axialToPixel(q, r);

      const graphics = new PIXI.Graphics();
      graphics.poly(HEX_PTS, true)
              .fill(0x000000, 0)
              .stroke({ color: 0xffffff, width: 1, alpha: 1 });

      graphics.x = x;
      graphics.y = y;
      graphics.eventMode = 'static';
      graphics.cursor = 'pointer';
      graphics.hitArea = new PIXI.Polygon(HEX_PTS);

      container.addChild(graphics);

      const text = new PIXI.Text({
        text: labelText || '',
        style: {
          fill: 0xffffff,
          fontSize: 12,
          fontFamily: 'system-ui, Arial',
          fontWeight: '500'
        }
      });
      text.anchor.set(0.5);
      text.x = x;
      text.y = y;
      container.addChild(text);

      return {
        graphics,
        text,
        q,
        r,
        selected: false,
        data: {}
      };
    };

    // Взаимодействия (копия из hex_test, плюс отправка данных наверх)
    const wireInteractions = (hexObj) => {
      // центральную «оранжевую» оставляем без hover
      if (hexObj === centerHex) return;

      hexObj.graphics.on('pointerover', () => {
        if (!hexObj.selected) {
          hexObj.graphics.clear()
                .poly(HEX_PTS, true)
                .fill(0x000000, 0)
                .stroke({ color: 0x34a2db, width: 2, alpha: 1 });
        }
      });

      hexObj.graphics.on('pointerout', () => {
        if (!hexObj.selected) {
          hexObj.graphics.clear()
                .poly(HEX_PTS, true)
                .fill(0x000000, 0)
                .stroke({ color: 0xffffff, width: 1, alpha: 1 });
        }
      });

      hexObj.graphics.on('pointertap', () => {
        if (selectedHex && selectedHex !== hexObj) {
          selectedHex.selected = false;
          selectedHex.graphics.clear()
                .poly(HEX_PTS, true)
                .fill(0x000000, 0)
                .stroke({ color: 0xffffff, width: 1, alpha: 1 });
        }

        if (hexObj.selected) {
          hexObj.selected = false;
          hexObj.graphics.clear()
                .poly(HEX_PTS, true)
                .fill(0x000000, 0)
                .stroke({ color: 0xffffff, width: 1, alpha: 1 });
          selectedHex = null;
        } else {
          hexObj.selected = true;
          selectedHex = hexObj;
          hexObj.graphics.clear()
                .poly(HEX_PTS, true)
                .fill(0x34a2db, 1)
                .stroke({ color: 0xffffff, width: 2, alpha: 1 });

          // отправляем данные выбранной соты в container.html
          if (window.parent && window.parent !== window) {
            window.parent.postMessage(
              { type: 'container:set', payload: hexObj.data || {} },
              '*'
            );
          }
        }
      });
    };

    // --- Нормализация входного объекта в список cells ---
    function normalizePixiPayload(raw) {
      if (!raw) return { format: 'pixi_hex', cells: [] };

      // если уже нормальный формат
      if (raw.format === 'pixi_hex' && Array.isArray(raw.cells)) {
        return raw;
      }

      let obj = raw;

      // n8n часто заворачивает в массив
      if (Array.isArray(obj)) {
        obj = obj[0];
      }

      // твой кейс: { "": { "L1": {...}, "L2-1": {...}, ... } }
      if (obj && typeof obj === 'object' && '' in obj && typeof obj[''] === 'object') {
        obj = obj[''];
      }

      // словарь id -> { q, r, label, data? }
      if (obj && typeof obj === 'object' && !Array.isArray(obj) && !obj.cells) {
        const cells = Object.values(obj).map((cell) => {
          if (!cell || typeof cell !== 'object') return null;
          const q = Number(cell.q) || 0;
          const r = Number(cell.r) || 0;
          const label = cell.label || '';
          const id = cell.id;

          return {
            q,
            r,
            label,
            data: {
              id,
              ...(cell.data || {})
            }
          };
        }).filter(Boolean);

        return { format: 'pixi_hex', cells };
      }

      return raw;
    }

    // --- Построение карты из cells ---
    function buildFromCells(cells) {
      clearMap();
      if (!cells || !cells.length) {
        console.warn('Pixi: пустой список cells');
        return;
      }

      // центрируем кластер по среднему q/r, чтобы он был вокруг (0,0)
      let sumQ = 0, sumR = 0;
      for (const c of cells) {
        sumQ += Number(c.q) || 0;
        sumR += Number(c.r) || 0;
      }
      const avgQ = sumQ / cells.length;
      const avgR = sumR / cells.length;

      cells.forEach((cell, idx) => {
        const q = (Number(cell.q) || 0) - avgQ;
        const r = (Number(cell.r) || 0) - avgR;
        const label = cell.label || '';
        const hex = createHex(q, r, label);
        hex.data = cell.data || cell;

        HEXES.push(hex);

        if (idx === 0) {
          // делаем первый узел «центральным» — оранжевая заливка, как в hex_test
          centerHex = hex;
          hex.graphics.clear()
              .poly(HEX_PTS, true)
              .fill(0xff622b, 1)
              .stroke({ color: 0xffffff, width: 1, alpha: 1 });
        } else {
          wireInteractions(hex);
        }
      });

      console.log('Pixi карта отрисована, всего сот:', HEXES.length);
    }

    // --- Публичный API для index.html ---
    function drawMap(raw) {
      console.log('Pixi: raw payload', raw);
      const norm = normalizePixiPayload(raw);
      console.log('Pixi: normalized payload', norm);
      buildFromCells(norm.cells || []);
    }

    window.PixiViewer = { setData: drawMap };

    // --- принимаем карту из index.html ---
    window.addEventListener('message', (ev) => {
      const msg = ev.data || {};
      if (msg.type === 'map:pixi') {
        drawMap(msg.payload);
      }
    });

    console.log('Pixi viewer готов. Ждёт { type:"map:pixi", payload: ... }');
  })();
  </script>
</body>
</html>
