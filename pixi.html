<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Pixi viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body {
      margin:0;
      height:100%;
      overflow:hidden;
      background:#1e1e1e;
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;
    }

    /* Панель для цветов (L1–L4) */
    .palette {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px;
      background: rgba(0,0,0,0.6);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
      z-index: 10;
      color: #eceff1;
      font-size: 11px;
    }

    .palette-row {
      display: flex;
      align-items: center;
      gap: 0;
    }

    .palette-label {
      min-width: 38px;
      font-size: 11px;
      opacity: 0.8;
    }

    .palette-center {
      width: 32px;
      height: 18px;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: 0 3px 8px rgba(0,0,0,0.5);
    }

    .palette-center input {
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      transition: all 0.2s ease;
    }

    .palette-center input:hover {
      transform: scale(1.1);
    }

    .palette-sector {
      position: absolute;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .palette-sector input {
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      box-shadow: 0 3px 8px rgba(0,0,0,0.3);
      transition: all 0.2s ease;
    }

    .palette-sector input:hover {
      transform: scale(1.15);
    }

    /* Расположение секторов по кругу */
    .palette-sector[data-sector="1"] { top: 10px; left: 50px; }  /* ↖ */
    .palette-sector[data-sector="2"] { top: 10px; right: 50px; } /* ↗ */
    .palette-sector[data-sector="3"] { top: 60px; right: 10px; } /* → */
    .palette-sector[data-sector="4"] { bottom: 10px; right: 50px; } /* ↘ */
    .palette-sector[data-sector="5"] { bottom: 10px; left: 50px; } /* ↙ */
    .palette-sector[data-sector="6"] { top: 60px; left: 10px; }   /* ← */

    /* Контейнер для канваса */
    #pixi-root {
      width:100%;
      height:100%;
    }
  </style>
</head>
<body>
  <div id="pixi-root"></div>

  <div class="palette">
    <div class="palette-row">
      <div class="palette-label">L1</div>
      <div class="palette-center">
        <input type="color" id="color-l1" />
      </div>
    </div>

    <div class="palette-row" style="position:relative;width:120px;height:120px;margin-top:4px;">
      <div class="palette-label" style="position:absolute;left:-4px;top:-6px;">L2</div>

      <div class="palette-sector" data-sector="1">
        <input type="color" data-sector-id="1" />
      </div>
      <div class="palette-sector" data-sector="2">
        <input type="color" data-sector-id="2" />
      </div>
      <div class="palette-sector" data-sector="3">
        <input type="color" data-sector-id="3" />
      </div>
      <div class="palette-sector" data-sector="4">
        <input type="color" data-sector-id="4" />
      </div>
      <div class="palette-sector" data-sector="5">
        <input type="color" data-sector-id="5" />
      </div>
      <div class="palette-sector" data-sector="6">
        <input type="color" data-sector-id="6" />
      </div>
    </div>
  </div>

  <script src="PixiJS/pixi.min.js"></script>
  <script>
    (function(){
      const root = document.getElementById('pixi-root');

      const app = new PIXI.Application({
        resizeTo: root,
        backgroundAlpha: 0,
        antialias: true
      });
      root.appendChild(app.view);

      const container = new PIXI.Container();
      app.stage.addChild(container);

      let size = 40;
      const HEX_PTS = (function createHexPoints(radius) {
        const points = [];
        for (let i = 0; i < 6; i++) {
          const angle = (Math.PI / 180) * (60 * i - 30);
          points.push(
            Math.cos(angle) * radius,
            Math.sin(angle) * radius
          );
        }
        return points;
      })(size);

      const HEXES = [];
      let selectedHex = null;
      let centerHex = null;

      const clearMap = () => {
        container.removeChildren();
        HEXES.length = 0;
        selectedHex = null;
        centerHex = null;
      };

      // ─── ХЕЛПЕР ПЕРЕНОСА ТЕКСТА (твои правила) ─────────────
      function wrapLabel(text, maxCharsSingle = 9, maxLineLenMulti = 10, maxLines = 4) {
        const str = String(text || '').trim();
        if (!str) return '';

        const words = str.split(/\s+/).filter(Boolean);
        const wordCount = words.length;

        const cutWord = (word) => {
          if (word.length <= maxCharsSingle) return word;
          return word.slice(0, maxCharsSingle) + '.';
        };

        // 1) ОДНО слово
        if (wordCount === 1) {
          return cutWord(words[0]);
        }

        const lines = [];

        // 2) 2 или 3 слова — каждое слово на своей строке
        if (wordCount === 2 || wordCount === 3) {
          for (let i = 0; i < wordCount && lines.length < maxLines; i++) {
            lines.push(cutWord(words[i]));
          }
          return lines.join('\n');
        }

        // 3) >3 слов — несколько слов в строке, но ≤ 10 символов
        let current = '';

        for (let i = 0; i < wordCount; i++) {
          let w = words[i];

          if (w.length > maxCharsSingle) {
            w = cutWord(w);
          }

          if (!current) {
            current = w;
          } else {
            const candidate = current + ' ' + w;
            if (candidate.length <= maxLineLenMulti) {
              current = candidate;
            } else {
              lines.push(current);
              if (lines.length >= maxLines) break;
              current = w;
            }
          }

          if (lines.length >= maxLines) break;
        }

        if (current && lines.length < maxLines && lines[lines.length - 1] !== current) {
          lines.push(current);
        }

        if (lines.length > maxLines) {
          lines.length = maxLines;
        }

        for (let i = 0; i < lines.length; i++) {
          const parts = lines[i].split(/\s+/).filter(Boolean);
          if (parts.length === 1 && lines[i].length > maxCharsSingle) {
            lines[i] = cutWord(parts[0]);
          }
        }

        return lines.join('\n');
      }

      // ─── ЦВЕТОВАЯ ПАЛИТРА L1–L4 ───────────────────────────────

      // базовые цвета L1 (центральная) и L2-1..L2-6
      const BASE_COLORS = {
        0: 0xff622b, // Центральная сота L1
        1: 0xd98073, // L2-1 ↖
        2: 0xffd9bf, // L2-2 ↗
        3: 0x61f29d, // L2-3 →
        4: 0x4991b6, // L2-4 ↘
        5: 0x6680cc, // L2-5 ↙
        6: 0xe64073  // L2-6 ←
      };

      function intToHexColor(intVal) {
        let s = intVal.toString(16);
        while (s.length < 6) s = '0' + s;
        return '#' + s;
      }

      function setupPaletteUI() {
        const inputs = document.querySelectorAll('input.palette-sector,input[data-sector-id],#color-l1');
        // здесь можно было бы инициализировать значения из BASE_COLORS при желании
      }

      setupPaletteUI();

      // ─── преобразование axial → pixel ─────────────────────────
      const axialToPixel = (q, r, radius = size) => {
        const x = radius * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
        const y = radius * (3/2 * r);
        return { x, y };
      };

      // определение уровня/сектора/порядка по node_id (L1, L2-1, L3-1-01, L4-1-01-01)
      function parseNodeLevel(nodeId, cell) {
        if (!nodeId || typeof nodeId !== 'string') {
          return { level: null, sector: null, order: null };
        }

        const re = /^L(\d)(?:-(\d)(?:-(\d{2})(?:-(\d{2}))?)?)?$/;
        const m = nodeId.match(re);
        let level = null, sector = null, order = null;

        if (m) {
          level  = parseInt(m[1], 10);
          if (m[2]) sector = parseInt(m[2], 10);
          if (m[3]) order = parseInt(m[3], 10);
        }

        if (!level) {
          const q = Number(cell.q) || 0;
          const r = Number(cell.r) || 0;
          const s = -q - r;
          const radius = Math.max(Math.abs(q), Math.abs(r), Math.abs(s));
          if (radius === 0) level = 1;
          else if (radius === 1) level = 2;
          else if (radius === 2) level = 3;
          else level = 4;
        }

        return { level, sector, order };
      }

      // определение цвета/прозрачности по уровню
      function getFillStyle(cell) {
        const nodeId = cell.node_id || cell.id || '';
        const { level, sector, order } = parseNodeLevel(nodeId, cell);

        // L1
        if (level === 1) {
          return { color: BASE_COLORS[0], alpha: 1 };
        }

        // Второй уровень (L2) - радиальный
        if (level === 2) {
          const baseColor = (sector && BASE_COLORS[sector]) ? BASE_COLORS[sector] : 0x000000;
          return { color: baseColor, alpha: 1 }; // alpha = 1
        }

        const baseColor = (sector && BASE_COLORS[sector]) ? BASE_COLORS[sector] : 0x000000;

        if (!sector) {
          return { color: baseColor, alpha: 0 };
        }

        // Третий уровень (L3)
        if (level === 3) {
          return { color: baseColor, alpha: 0.5 }; // alpha = 0.5
        }

        // Четвертый уровень (L4) и выше
        if (level >= 4) {
          const idx = order || 1;
          const isOdd = idx % 2 === 1;
          const alpha = isOdd ? 0.2 : 0.1; // чередование 0.2 и 0.1
          return { color: baseColor, alpha };
        }

        return { color: baseColor, alpha: 0 };
      }

      // ─── создание одной соты ───────────────────────────────────
      const createHex = (cell) => {
        const q = Number(cell.q) || 0;
        const r = Number(cell.r) || 0;
        const labelText = cell.label || '';
        const { x, y } = axialToPixel(q, r);

        const { color: fillColor, alpha: fillAlpha } = getFillStyle(cell);

        const graphics = new PIXI.Graphics();
        graphics.poly(HEX_PTS, true)
                .fill(fillColor, fillAlpha)
                .stroke({ color: 0xffffff, width: 1, alpha: 1 });

        graphics.x = x;
        graphics.y = y;
        graphics.eventMode = 'static';
        graphics.cursor = 'pointer';
        graphics.hitArea = new PIXI.Polygon(HEX_PTS);

        container.addChild(graphics);

        const wrapped = wrapLabel(labelText);
        const text = new PIXI.Text({
          text: wrapped,
          style: {
            fill: 0xffffff,
            fontSize: 11,
            fontFamily: 'system-ui, Arial',
            fontWeight: '500',
            align: 'center'
          }
        });
        text.anchor.set(0.5);
        text.x = x;
        text.y = y;
        container.addChild(text);

        const baseData = (cell && typeof cell.data === 'object') ? cell.data : (cell || {});
        const node_id = baseData.node_id || baseData.id || cell.id || null;
        const label = labelText || baseData.label || baseData.topic || '';
        const payloadForContainer = Object.assign({}, baseData, {
          node_id,
          label
        });

        return {
          graphics,
          text,
          q,
          r,
          selected: false,
          data: payloadForContainer,
          baseFillColor: fillColor,
          baseFillAlpha: fillAlpha
        };
      };

      const applyBaseStyle = (hexObj) => {
        hexObj.graphics
          .clear()
          .poly(HEX_PTS, true)
          .fill(hexObj.baseFillColor, hexObj.baseFillAlpha)
          .stroke({ color: 0xffffff, width: 1, alpha: 1 });
      };

      const wireInteractions = (hexObj) => {
        if (hexObj === centerHex) return;

        hexObj.graphics.on('pointerover', () => {
          if (!hexObj.selected) {
            hexObj.graphics.clear()
                  .poly(HEX_PTS, true)
                  .fill(hexObj.baseFillColor, hexObj.baseFillAlpha)
                  .stroke({ color: 0x34a2db, width: 2, alpha: 1 });
          }
        });

        hexObj.graphics.on('pointerout', () => {
          if (!hexObj.selected) {
            applyBaseStyle(hexObj);
          }
        });

        hexObj.graphics.on('pointertap', () => {
          if (selectedHex && selectedHex !== hexObj) {
            selectedHex.selected = false;
            applyBaseStyle(selectedHex);
          }

          if (hexObj.selected) {
            hexObj.selected = false;
            applyBaseStyle(hexObj);
            selectedHex = null;
          } else {
            hexObj.selected = true;
            selectedHex = hexObj;
            hexObj.graphics.clear()
                  .poly(HEX_PTS, true)
                  .fill(0x34a2db, 1)
                  .stroke({ color: 0xffffff, width: 2, alpha: 1 });

            if (window.parent && window.parent !== window) {
              window.parent.postMessage(
                { type: 'container:set', payload: hexObj.data || {} },
                '*'
              );
            }
          }
        });
      };

      // ─── нормализация payload ──────────────────────────────────
      function normalizePixiPayload(raw) {
        if (!raw) return { format: 'pixi_hex', cells: [] };

        if (raw.format === 'pixi_hex' && Array.isArray(raw.cells)) {
          return raw;
        }

        let obj = raw;

        if (Array.isArray(obj)) {
          obj = obj[0] || {};
        }

        if (obj && Array.isArray(obj.cells)) {
          return obj;
        }

        if (Array.isArray(obj)) {
          return { format: 'pixi_hex', cells: obj };
        }

        if (obj && Array.isArray(obj.data)) {
          return { format: 'pixi_hex', cells: obj.data };
        }

        return { format: 'pixi_hex', cells: [] };
      }

      function renderPixiMap(raw) {
        const { cells } = normalizePixiPayload(raw);
        clearMap();

        cells.forEach(cell => {
          const hex = createHex(cell);
          HEXES.push(hex);
          if (!centerHex && (!cell.node_id || cell.node_id === 'L1')) {
            centerHex = hex;
          }
          wireInteractions(hex);
        });

        if (centerHex) {
          applyBaseStyle(centerHex);
          centerHex.graphics.clear()
            .poly(HEX_PTS, true)
            .fill(centerHex.baseFillColor, centerHex.baseFillAlpha)
            .stroke({ color: 0xffffff, width: 2, alpha: 1 });
        }
      }

      window.addEventListener('message', (ev) => {
        const msg = ev.data || {};
        if (msg.type === 'map:pixi') {
          // ожидаем msg.payload в любом виде, normalizePixiPayload разберется
          renderPixiMap(msg.payload);
        }
        if (msg.type === 'pixi:resize') {
          app.renderer.resize(root.clientWidth, root.clientHeight);
        }
      });

    })();
  </script>
</body>
</html>
