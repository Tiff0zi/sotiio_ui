<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>sotiio user story</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: #f6f6f6;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      overflow: auto;
    }
    
    .wrap {
      max-width: 820px;
      margin: 0 auto;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 12px 32px rgba(0,0,0,.08);
      padding: 22px 26px;
      height: auto;
      min-height: 100%;
      position: relative;
    }
    
    h1 {
      margin: 6px 0 18px 0;
      font-size: 22px;
      color: #1f1f1f;
    }
    
    .row {
      margin: 18px 0;
    }
    
    .label {
      font-weight: 700;
      margin-bottom: 10px;
      font-size: 15px;
    }
    
    .roles {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .roles label {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 15px;
    }
    
    .text-input {
      width: 100%;
      padding: 12px 14px;
      border: 1px solid #ddd;
      border-radius: 10px;
      font-size: 15px;
      font-family: inherit;
    }
    
    .options-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(240px, 1fr));
      gap: 10px;
      margin-top: 8px;
    }
    
    .option-card {
      border: 1px solid #e6e6e6;
      padding: 12px 14px;
      border-radius: 10px;
      cursor: pointer;
      background: #fff;
      font-size: 14px;
      transition: all 0.2s;
    }
    
    .option-card.selected {
      border-color: #ff622b;
      background: rgba(255, 98, 43, 0.06);
    }
    
    .add-own {
      margin-top: 12px;
      position: relative;
    }
    
    .add-own .text-input {
      padding-right: 46px;
    }
    
    .add-own .add-btn {
      position: absolute;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      height: 34px;
      min-width: 34px;
      padding: 0 10px;
      background: #f7f7f7;
      border: 1px solid #ddd;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }
    
    .add-own .add-btn:hover {
      background: #ececec;
    }
    
    .chiplist {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 10px;
    }
    
    .chip {
      background: #f3f4f6;
      border: 1px solid #e5e7eb;
      padding: 6px 10px;
      border-radius: 16px;
      font-size: 13px;
    }
    
    .actions {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      margin-top: 20px;
      gap: 12px;
    }
    
    .primary-btn {
      background: #ff622b;
      color: #fff;
      border: none;
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      font-family: inherit;
    }
    
    .primary-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .muted {
      font-size: 13px;
      color: #666;
    }
    
    .divider {
      height: 1px;
      background: rgba(0,0,0,0.05);
      border: 0;
      margin: 20px 0;
      width: 100%;
    }
    
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 12px;
      z-index: 100;
    }
    
    .loading-overlay.active {
      display: flex;
    }
    
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #ff622b;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }
    
    .loading-text {
      font-size: 16px;
      color: #333;
      text-align: center;
    }
    
    .loading-details {
      font-size: 14px;
      color: #666;
      margin-top: 8px;
      text-align: center;
    }
    
    .progress-bar {
      width: 300px;
      height: 6px;
      background: #f0f0f0;
      border-radius: 3px;
      margin: 20px 0;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background: #ff622b;
      border-radius: 3px;
      width: 0%;
      transition: width 0.3s ease;
    }
    
    .timer {
      font-size: 14px;
      color: #666;
      margin-top: 10px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @media (max-width: 768px) {
      .wrap {
        margin: 0;
        padding: 18px;
        border-radius: 0;
        box-shadow: none;
      }
      
      .options-grid {
        grid-template-columns: 1fr;
      }
      
      h1 {
        font-size: 20px;
      }
      
      .progress-bar {
        width: 250px;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="loading-overlay" id="loadingOverlay">
      <div class="spinner"></div>
      <div class="loading-text">Создаём вашу карту знаний...</div>
      <div class="loading-details">Это может занять от 3 до 7 минут</div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="timer" id="timer">Прошло: 0:00</div>
      <div class="loading-details" id="loadingDetails">Инициализация процесса...</div>
    </div>
    
    <h1>Новое исследование</h1>
    
    <div class="row">
      <div class="label">Я как…</div>
      <div class="roles">
        <label><input type="radio" name="role" value="Novice"> Новичок</label>
        <label><input type="radio" name="role" value="Enthusiast"> Увлекающийся</label>
        <label><input type="radio" name="role" value="Geek"> Гик</label>
        <label><input type="radio" name="role" value="Pro"> Профи</label>
      </div>
    </div>

    <div class="divider"></div>

    <div class="row">
      <div class="label">Хочу изучить…</div>
      <input id="subject" class="text-input" 
             placeholder="Например: Киновселенную Marvel, мир крипто-активов, Эволюцию человека…">
      <div class="muted" style="margin-top:6px">Укажите любую вселенную для изучения.</div>
    </div>

    <div class="divider"></div>

    <div class="row">
      <div class="label">Чтобы…</div>
      <div id="opts" class="options-grid"></div>
      <div class="add-own">
        <input id="own" class="text-input" placeholder="Предложите свой вариант и нажмите Enter">
        <button class="add-btn" id="addOwn" title="Добавить">＋</button>
      </div>
      <div id="chips" class="chiplist"></div>
    </div>

    <div class="actions">
      <div id="status" class="muted"></div>
      <button id="submit" class="primary-btn">Отправить</button>
    </div>
  </div>

  <script>
  (function(){
    const optsBox = document.getElementById('opts');
    const ownInput = document.getElementById('own');
    const addOwnBtn = document.getElementById('addOwn');
    const chips = document.getElementById('chips');
    const status = document.getElementById('status');
    const submit = document.getElementById('submit');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const loadingDetails = document.getElementById('loadingDetails');
    const progressFill = document.getElementById('progressFill');
    const timer = document.getElementById('timer');

    let currentMapId = null;
    let startTime = null;
    let timerInterval = null;
    let showElapsedInDetails = false; // только для текста статуса, структура не меняется

    const roleTexts = {
      "Novice": [
        "Быстро сориентироваться в теме и не чувствовать себя потерянным",
        "Понимать, о чём говорят другие, и поддерживать базовый разговор",
        "Отличать ключевые понятия от второстепенных и не тратить время зря",
        "Иметь надёжную «шпаргалку» по основам",
        "Понять, интересна ли тема для дальнейшего углубления",
        "Избежать элементарных ошибок и неловких ситуаций",
        "Удовлетворить любопытство и получить общий обзор",
        "Понять, как это связано с реальной жизнью и где применяется",
        "Быть в курсе текущих трендов и популярных тем",
        "Упорядочить начальные знания и почувствовать уверенность"
      ],
      "Enthusiast": [
        "Разобраться, как всё устроено внутри, а не только знать факты",
        "Видеть логические связи между частями системы",
        "Уметь просто и ясно объяснять сложные вещи другим",
        "Начать применять знания в повседневной жизни или работе",
        "Научиться рассуждать самостоятельно и делать обоснованные выводы",
        "Структурировать знания и понять, что изучать дальше",
        "Видеть целостную картину: историю и возможное развитие",
        "Сравнивать систему с альтернативами и видеть сильные и слабые стороны",
        "Получать интеллектуальное удовольствие от освоения сложного",
        "Превратить хаос разрозненных фактов в стройную систему"
      ],
      "Geek": [
        "Эффективно использовать инструменты и техники для решения задач",
        "Получать конкурентное преимущество за счёт глубоких знаний",
        "Стать признанным экспертом, к которому обращаются за советом",
        "Находить и применять лучшие практики для максимального результата",
        "Монетизировать знания и навыки в этой области",
        "Критически оценивать решения, находя слабые места и уязвимости",
        "Эффективно обучать и наставлять других, передавая опыт",
        "Принимать продуманные тактические решения и управлять процессами",
        "Адаптировать стандартные подходы под нестандартные задачи",
        "Уверенно побеждать в дискуссиях, опираясь на факты"
      ],
      "Pro": [
        "Видеть систему целиком и задавать стратегию её развития",
        "Создавать новые концепции, системы и продукты на основе глубокого анализа",
        "Находить «белые пятна» и точки прорыва для инноваций",
        "Проектировать сложные системы с нуля, понимая их фундаментальные принципы",
        "Трансформировать существующие системы, а не только оптимизировать",
        "Принимать взвешенные стратегические решения с высокой ценой ошибки",
        "Формировать видение будущего и вести за собой команду или отрасль",
        "Выступать мыслительным лидером, влияя на развитие индустрии",
        "Оставлять значимый след и вносить фундаментальный вклад в область",
        "Видеть скрытые рычаги влияния и прогнозировать долгосрочные последствия"
      ]
    };

    document.querySelectorAll('input[name="role"]').forEach(r=>{
      r.addEventListener('change', ()=>{
        const role = document.querySelector('input[name="role"]:checked')?.value;
        optsBox.innerHTML = '';
        const list = roleTexts[role] || [];
        for(const v of list){
          const div = document.createElement('div');
          div.className = 'option-card';
          div.textContent = v;
          div.dataset.value = v;
          optsBox.appendChild(div);
        }
        syncChips();
      });
    });

    optsBox.addEventListener('click', e=>{
      const card = e.target.closest('.option-card');
      if(!card) return;
      card.classList.toggle('selected');
      syncChips();
    });

    function syncChips(){
      chips.innerHTML = '';
      const selected = Array.from(optsBox.querySelectorAll('.option-card.selected'))
                          .map(x => x.dataset.value);
      for(const s of selected){
        const c = document.createElement('span');
        c.className = 'chip';
        c.textContent = s;
        chips.appendChild(c);
      }
    }

    function addOwn(){
      const val = ownInput.value.trim();
      if(!val) return;
      let existing = Array.from(optsBox.children).find(x => x.dataset.value === val);
      if(!existing){
        const div = document.createElement('div');
        div.className = 'option-card selected';
        div.textContent = val;
        div.dataset.value = val;
        optsBox.prepend(div);
      } else {
        existing.classList.add('selected');
      }
      ownInput.value = '';
      syncChips();
    }
    ownInput.addEventListener('keydown', e=>{
      if(e.key === 'Enter'){
        e.preventDefault();
        addOwn();
      }
    });
    addOwnBtn.addEventListener('click', addOwn);

    function two(n){ return String(n).padStart(2,'0'); }
    function mapIdFromNow(){
      const d = new Date();
      const ss = two(d.getSeconds());
      const mm = two(d.getMinutes());
      const hh = two(d.getHours());
      const dd = two(d.getDate());
      const MM = two(d.getMonth()+1);
      const yy = two(d.getFullYear()%100);
      return `${ss}${mm}${hh}${dd}${MM}${yy}`;
    }
    const say = (m, c) => {
      status.textContent = m;
      status.style.color = c || '#333';
    };

    // таймер + прогресс; добавил вывод elapsed в loadingDetails по флагу
    function updateTimer() {
      if (!startTime) return;
      const now = new Date();
      const diff = Math.floor((now - startTime) / 1000);
      const minutes = Math.floor(diff / 60);
      const seconds = diff % 60;
      const mmss = `${minutes}:${two(seconds)}`;
      timer.textContent = `Прошло: ${mmss}`;
      const progress = Math.min((diff / 600) * 100, 100);
      progressFill.style.width = `${progress}%`;
      if (showElapsedInDetails) {
        loadingDetails.textContent = `Ожидаем создание карты… (прошло ${mmss})`;
      }
    }

    // fetch с таймаутом 5с
    async function fetchWithTimeout(url, options = {}, timeoutMs = 5000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeoutMs);
      try {
        return await fetch(url, { ...options, signal: controller.signal });
      } finally {
        clearTimeout(id);
      }
    }

    // ОТПРАВКА
    submit.addEventListener('click', async ()=>{
      const role = document.querySelector('input[name="role"]:checked')?.value;
      const subject = document.getElementById('subject').value.trim();
      const chosen = Array.from(optsBox.querySelectorAll('.option-card.selected'))
                         .map(x => x.dataset.value);

      if(!role){ say('Выберите роль.', 'crimson'); return; }
      if(!subject){ say('Укажите тему/вселенную.', 'crimson'); return; }
      if(chosen.length === 0){ say('Выберите хотя бы один вариант в «Чтобы…» или добавьте свой.', 'crimson'); return; }

      currentMapId = mapIdFromNow();
      startTime = new Date();

      submit.disabled = true;
      loadingOverlay.classList.add('active');
      say('');

      timerInterval = setInterval(updateTimer, 1000);
      updateTimer();

      const payload = {
        source: 'sotiio_web_survey',
        map_id: currentMapId,
        user_story: {
          "I_as...": role,
          "Want_to_discover_a_universe...": subject,
          "So_that...": chosen,
          timestamp: (new Date()).toISOString()
        }
      };

      // 1. создание карты (как было)
      fetch('https://n8n.sotiio.com/webhook/us', {
        method: 'POST',
        mode: 'no-cors',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      })
      .then(() => {
        loadingDetails.textContent = 'Запрос на создание карты отправлен...';
      })
      .catch((error) => {
        console.warn('Предупреждение при отправке:', error);
      })
      .finally(async () => {
        // 2. БЕЗ задержки в 10с — сразу один запрос за картой с таймаутом 5с
        showElapsedInDetails = true;
        updateTimer();

        try {
          const response = await fetchWithTimeout('https://n8n.sotiio.com/webhook/getmap', {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'Accept': 'application/json'
            },
            body: JSON.stringify({ map_id: currentMapId })
          }, 5000);

          if (!response.ok) throw new Error(`HTTP ${response.status}`);

          const data = await response.text().then(text => {
            try { return text ? JSON.parse(text) : []; }
            catch { throw new Error('Невалидный JSON ответ от сервера'); }
          });

          clearInterval(timerInterval);
          loadingOverlay.classList.remove('active');

          // разбор структуры — как в исходнике
          let mapData = null;
          if (Array.isArray(data) && data.length > 0) {
            const firstItem = data[0];
            if (firstItem && firstItem.map) mapData = firstItem.map;
            else if (firstItem && typeof firstItem === 'object') mapData = firstItem;
            else if (firstItem && firstItem.data && firstItem.data.map) mapData = firstItem.data.map;
            else if (firstItem && firstItem.payload) mapData = firstItem.payload;
          } else if (data && data.map) {
            mapData = data.map;
          } else if (data && typeof data === 'object') {
            mapData = data;
          }

          if (mapData) {
            console.log('Получены данные карты:', mapData);

            // ВОЗВРАЩАЮ исходный порядок: СНАЧАЛА отрисовка (postMessage)…
            if (window.parent && window.parent !== window) {
              window.parent.postMessage({ 
                type: 'map:set', 
                payload: {
                  map: mapData,
                  rawResponse: data
                }
              }, '*');
            }
            // …ПОТОМ закрытие модалки (как было)
            setTimeout(() => {
              if (window.parent && window.parent.UI) {
                window.parent.UI.closeUserStory();
              }
            }, 1000);

          } else {
            console.warn('Неожиданная структура ответа:', data);
            say('Карта не была создана. Неожиданный формат ответа.', 'crimson');
            submit.disabled = false;
          }
        } catch (error) {
          clearInterval(timerInterval);
          loadingOverlay.classList.remove('active');
          const msg = (error && error.name === 'AbortError')
            ? 'Таймаут запроса карты (5 сек).'
            : 'Ошибка при получении карты: ' + error.message;
          say(msg, 'crimson');
          submit.disabled = false;
        }
      });
    });

    window.addEventListener('beforeunload', () => {
      if (timerInterval) clearInterval(timerInterval);
    });
  })();
  </script>
</body>
</html>
