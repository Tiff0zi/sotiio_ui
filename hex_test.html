<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Pixi sanity check (v7/v8)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; background:#202020; overflow:hidden; }
    #app { width:100vw; height:100vh; }
    #msg { position:fixed; left:10px; top:10px; color:#fff; font:14px system-ui; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="msg">init…</div>

  <!-- ВАЖНО: путь к твоему файлу -->
  <script src="./PixiJS/pixi.min.js?v=2"></script>

  <script>
  (async function () {
    const log = (t, err=false) => {
      const el = document.getElementById('msg'); el.textContent = t; el.style.color = err ? '#ff6b6b' : '#ffffff';
      console[err ? 'error' : 'log'](t);
    };

    if (!window.PIXI) { log('PIXI не загрузился: проверь путь ./PixiJS/pixi.min.js', true); return; }

    // Создаём приложение: v8 -> new PIXI.Application(); await init(...)
    //                     v7 -> new PIXI.Application(opts)
    let app;
    try {
      app = new PIXI.Application();
      if (app.init) {
        await app.init({ resizeTo: window, background: '#202020', antialias: true }); // v8
      } else {
        app = new PIXI.Application({ backgroundColor: 0x202020, antialias: true, resizeTo: window }); // v7
      }
    } catch (e) {
      // если new PIXI.Application() требует opts (старый v7)
      app = new PIXI.Application({ backgroundColor: 0x202020, antialias: true, resizeTo: window });
    }

    // Добавляем canvas (v8 -> app.canvas, v7 -> app.view)
    const canvas = app.canvas || app.view;
    document.getElementById('app').appendChild(canvas);

    // Рисуем СИНИЙ прямоугольник — если его видно, Pixi работает
    const g = new PIXI.Graphics();
    if (typeof g.rect === 'function') {
      // v8 API
      g.rect(20, 20, 160, 90).fill({ color: 0x3b82f6 });
    } else {
      // v7 API
      g.beginFill(0x3b82f6);
      g.drawRect(20, 20, 160, 90);
      g.endFill();
    }
    app.stage.addChild(g);

    // ---------- HEX РЕНДЕР ----------
    // общий размер и предрасчитанные точки шестиугольника (pointy-top)
    const size = 40;
    const pts = [];
    for (let i = 0; i < 6; i++) {
      const a = (Math.PI / 180) * (60 * i - 30); // pointy-top
      pts.push(Math.cos(a) * size, Math.sin(a) * size);
    }

    // экранный центр
    const w = (app.renderer?.width) || canvas.width;
    const h = (app.renderer?.height) || canvas.height;
    const cx = w / 2, cy = h / 2;

    // axial -> pixel
    const SQRT3 = Math.sqrt(3);
    const axialToPixel = (q, r) => ({
      x: size * (SQRT3 * q + (SQRT3 / 2) * r),
      y: size * (1.5 * r)
    });

    // универсальная отрисовка гекса для v8/v7
    const isV8 = (typeof (new PIXI.Graphics()).poly === 'function');
    function drawHexAt(q, r, color, alpha=0.75, strokeAlpha=0.35) {
      const { x, y } = axialToPixel(q, r);
      const hex = new PIXI.Graphics();
      if (isV8) {
        hex.poly(pts, true).fill({ color, alpha }).stroke({ color: 0xffffff, width: 1, alpha: strokeAlpha });
      } else {
        hex.lineStyle(1, 0xffffff, strokeAlpha);
        hex.beginFill(color, alpha);
        hex.drawPolygon(pts);
        hex.endFill();
      }
      hex.x = cx + x; hex.y = cy + y;
      app.stage.addChild(hex);

      // подпись q,r (опционально)
      let t;
      try { t = new PIXI.Text({ text: `${q},${r}`, style: { fill: 0xffffff, fontSize: 12 } }); }
      catch { t = new PIXI.Text(`${q},${r}`, { fill: 0xffffff, fontSize: 12 }); }
      t.anchor?.set?.(0.5); t.x = hex.x; t.y = hex.y;
      app.stage.addChild(t);
    }

    // 1) центр (зелёный)
    drawHexAt(0, 0, 0x82b07a, 0.85);

    // 2) шесть направлений (для pointy-top)
    const DIRS = [
      {q:+1, r: 0}, {q:+1, r:-1}, {q: 0, r:-1},
      {q:-1, r: 0}, {q:-1, r:+1}, {q: 0, r:+1}
    ];

    // 3) кольцо радиуса 1 — 6 соседей (синие)
    const ring1 = [];
    for (const d of DIRS) {
      const nq = d.q, nr = d.r;
      ring1.push({ q: nq, r: nr, dir: d });
      drawHexAt(nq, nr, 0x6aa9ff, 0.70);
    }

    // 4) от каждого соседа — луч из 3 гексов наружу по его направлению (оранжевые)
    for (const h1 of ring1) {
      const { q, r, dir:{ q: dq, r: dr } } = h1;
      for (let step = 1; step <= 3; step++) {
        drawHexAt(q + dq*step, r + dr*step, 0xffb86b, 0.80);
      }
    }

    log('OK: центр + 6 вокруг + лучи по 3');
  })();
  </script>
</body>
</html>
