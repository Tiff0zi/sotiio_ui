<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Pixi Hex Demo (white background)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { margin:0; height:100%; overflow:hidden; background:#ffffff; }
    #msg { position:fixed; left:10px; top:10px; font:13px system-ui; color:#111; background:#fff8; padding:6px 10px; border-radius:8px; }
  </style>
</head>
<body>
  <div id="msg">init…</div>
  <script src="./PixiJS/pixi.min.js"></script>

  <script>
  (async () => {
    const M = (t, bad=false)=>{ const el=document.getElementById('msg'); el.textContent=t; el.style.color=bad?'#b00020':'#111'; console[bad?'error':'log'](t); };

    if (!window.PIXI) { M('PIXI не найден', true); return; }
    const app = new PIXI.Application();
    await app.init({
      resizeTo: window,
      background: '#ffffff',
      antialias: true,
      resolution: Math.min(3, window.devicePixelRatio || 1)
    });
    document.body.appendChild(app.canvas);

    const cam = new PIXI.Container();
    app.stage.addChild(cam);

    // --- Пан/Зум ---
    let drag=false, prev=null, zoom=1;
    app.stage.eventMode='static'; app.stage.hitArea=app.screen;
    app.stage.on('pointerdown',e=>{drag=true;prev=e.global.clone();});
    app.stage.on('pointerup',()=>{drag=false;prev=null;});
    app.stage.on('pointerupoutside',()=>{drag=false;prev=null;});
    app.stage.on('pointermove',e=>{
      if(!drag)return;const n=e.global.clone();cam.x+=n.x-prev.x;cam.y+=n.y-prev.y;prev=n;
    });
    app.canvas.addEventListener('wheel',ev=>{
      ev.preventDefault();const s=ev.deltaY<0?1.1:0.9;const next=Math.min(4,Math.max(0.25,zoom*s));
      const cx=app.renderer.width/2,cy=app.renderer.height/2;const k=next/zoom;
      cam.x=cx+(cam.x-cx)*k;cam.y=cy+(cam.y-cy)*k;zoom=next;cam.scale.set(zoom);
    },{passive:false});

    // --- HEX математика ---
    const SQRT3=Math.sqrt(3), size=42;
    const axialToPixel=(q,r)=>({x:size*(SQRT3*q+SQRT3/2*r),y:size*(1.5*r)});
    const HEX_PTS=(()=>{const p=[];for(let i=0;i<6;i++){const a=(Math.PI/180)*(60*i-30);p.push(Math.cos(a)*size,Math.sin(a)*size);}return p;})();
    const makePolygon = (pts)=> new PIXI.Polygon(pts.reduce((arr,_,i)=> (i%2===0?arr.push({x:pts[i],y:pts[i+1]}):arr,arr),[]).map(p=>[p.x,p.y]).flat());

    // универсальная перерисовка одной соты
    const redrawHex = (g, fillColor, fillAlpha, strokeColor, strokeWidth=1, strokeAlpha=0.25) => {
      g.clear();
      g.poly(HEX_PTS, true)
       .fill({ color: fillColor, alpha: fillAlpha })
       .stroke({ color: strokeColor, width: strokeWidth, alpha: strokeAlpha, alignment: 0.5 });
    };

    // создаёт соту + кольцо ховера + метку
    const createHex = (q,r,baseColor,baseAlpha,strokeColor,labelText,labelColor)=>{
      const {x,y}=axialToPixel(q,r);

      // основная сота
      const g = new PIXI.Graphics();
      redrawHex(g, baseColor, baseAlpha, strokeColor, 1, 0.25);
      g.x=x; g.y=y;
      g.eventMode='static';
      g.cursor='pointer';
      g.hitArea = makePolygon(HEX_PTS); // точный хит-тест
      cam.addChild(g);

      // «свечение» при ховере (толстый контур, чуть больше масштаб)
      const hoverRing = new PIXI.Graphics();
      hoverRing.poly(HEX_PTS, true)
               .stroke({ color: 0x000000, width: 3, alpha: 0.35, alignment: 0.5 });
      hoverRing.x=x; hoverRing.y=y;
      hoverRing.scale.set(1.06);
      hoverRing.visible=false;
      cam.addChild(hoverRing);

      // метка
      const t=new PIXI.Text({text:labelText,style:{fill:labelColor,fontSize:12,fontFamily:'system-ui,Arial'}});
      t.anchor.set(0.5); t.x=x; t.y=y;
      cam.addChild(t);

      return { g, hoverRing, t, q, r, baseColor, baseAlpha, strokeColor, selected:false };
    };

    const addLabel=(x,y,text,color=0x111111)=>{
      const t=new PIXI.Text({text,style:{fill:color,fontSize:12,fontFamily:'system-ui,Arial'}});
      t.anchor.set(0.5);t.x=x;t.y=y;cam.addChild(t);
    };

    // --- Цвета из color.json (если есть) ---
    let palette;
    try {
      const c = await fetch('./color.json').then(r=>r.json());
      const toHex = s => s?.startsWith('#') ? parseInt(s.slice(1),16) : 0x6aa9ff;
      palette = {
        L1: toHex(c.fill_sota) || 0x1a1a1a,
        L2: Array.isArray(c.color_sota) ? c.color_sota.map(x=>parseInt(x.replace('#',''),16)) :
            ['#59a3a9','#d9e6e6','#996666','#735c59','#808080','#b84d5c'].map(h=>parseInt(h.replace('#',''),16)),
        stroke: parseInt((c.stroke_sota||'#000000').replace('#',''),16),
        label: parseInt((c.color_label||'#111111').replace('#',''),16)
      };
    } catch(e){
      palette = { L1:0x1a1a1a, L2:[0x59a3a9,0xd9e6e6,0x996666,0x735c59,0x808080,0xb84d5c],
                  stroke:0x000000, label:0x111111 };
    }

    // --- Генерация демо-карты (центр + 6 + лучи) ---
    const DIRS=[{q:+1,r:0},{q:+1,r:-1},{q:0,r:-1},{q:-1,r:0},{q:-1,r:+1},{q:0,r:+1}];
    cam.x=app.renderer.width/2; cam.y=app.renderer.height/2;

    const HEXES = [];
    let selectedHex = null;
    const YELLOW = 0xffeb3b;

    const wireInteractions = (hexObj) => {
      const { g, hoverRing } = hexObj;

      g.on('pointerover', () => {
        if (!hexObj.selected) {
          hoverRing.visible = true;
          // мягкое «подсвечивание»: чуть плотнее контур и альфа заливки
          redrawHex(g, hexObj.baseColor, Math.min(1, hexObj.baseAlpha + 0.15), hexObj.strokeColor, 2, 0.55);
        }
      });

      g.on('pointerout', () => {
        if (!hexObj.selected) {
          hoverRing.visible = false;
          redrawHex(g, hexObj.baseColor, hexObj.baseAlpha, hexObj.strokeColor, 1, 0.25);
        }
      });

      g.on('pointertap', () => {
        // если кликаем по уже выбранной — снять выделение
        if (hexObj.selected) {
          hexObj.selected = false;
          hoverRing.visible = false;
          redrawHex(g, hexObj.baseColor, hexObj.baseAlpha, hexObj.strokeColor, 1, 0.25);
          selectedHex = null;
          return;
        }
        // снять выделение с предыдущей
        if (selectedHex && selectedHex !== hexObj) {
          selectedHex.selected = false;
          selectedHex.hoverRing.visible = false;
          redrawHex(selectedHex.g, selectedHex.baseColor, selectedHex.baseAlpha, selectedHex.strokeColor, 1, 0.25);
        }
        // выделить текущую жёлтым
        hexObj.selected = true;
        selectedHex = hexObj;
        hoverRing.visible = true;
        redrawHex(g, YELLOW, 0.95, 0x000000, 2.5, 0.9);
      });
    };

    // центр
    const center = createHex(0,0,palette.L1,0.9,palette.stroke,'Center',palette.label);
    wireInteractions(center);
    HEXES.push(center);

    // 6 направлений
    for(let i=0;i<6;i++){
      const {q,r}=DIRS[i];
      const main = createHex(q,r,palette.L2[i%palette.L2.length],0.9,palette.stroke,`R1-${i+1}`,palette.label);
      wireInteractions(main);
      HEXES.push(main);

      // луч из 3 (полупрозрачные)
      for(let s=1;s<=3;s++){
        const qq=q+s*DIRS[i].q, rr=r+s*DIRS[i].r;
        const node = createHex(qq,rr,palette.L2[i%palette.L2.length],0.4,palette.stroke,``,palette.label);
        wireInteractions(node);
        HEXES.push(node);
      }
    }

    M('OK: белый фон, пан/зум; hover-подсветка; клик — жёлтое выделение (одна сота за раз).');
  })();
  </script>
</body>
</html>
